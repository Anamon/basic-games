Yat-C

For those in the know here is another obvious takeoff of a commercial
board game.  Whether you recognize the traits and the departures from
Yahtzee or not, it is the program that drives this game that is worth
studying.

The game is played by two persons taking turns, rolling five dice.  A
game is over when either passes 500 points; high score wins.  In turn
each player is given three chances to better his or her hand before
scoring the round.  The options are to pass, hold on to any one number
and roll the other four, or to roll a particular number, leaving four
as they lie.  The choice in each case depends on a knowledge of how
score is derived and an intuitive feel for the odds of what is apt to
happen in another roll.

Straights are hard to fill, as any poker player will tell you.  In
this game a one through five series or two through six is worth 200
points.  Matches are scored by multiplying the number in a set by the
total of the five dice.  For example, assume the series 4-1-5-4-4
remains after a player's third roll.  The score for this turn is
fifty- four.  (There are three fours; the sum of the five numbers is
eighteen; three times eighteen is fifty-four.)  There is one other
possibility: no straight and no matches.  The program calls this hand
a natural.  The score for a natural is simply the sum of the five
dice.

A full house exits when two dice have one value and the remaining
three have another single value.  In this case the score is twice the
sum of the pair and thrice the sum of the triplets.

All of these mechanics may be easily changed.  This program is fun to
have in your library as-is, and it provides opportunities for
experimenting with end-of-game limits and scoring points permutations.
As implied earlier these are not the only reasons for including this
design in this book.

The regular position of Y as next to the last affords an opportunity
to contrast a complex design with the dramatic simplicity that will be
found in Chapter Z.  The complexity of Yat-C is not in its procedural
logic; rather, it is in its structural organization.  In some schools
this design would come close to being described as over engineered.

That is why there is opportunity here to extol, a last time, my
propensity for the template method of documenting BASIC programs.  At
a glance the picture in Fig. Y-1 may in fact look like a plumber's
nightmare.  Yet, with the briefest study a sense of reason can be
gleaned from it.

Not much time has been spent elsewhere on how templates are formed, so
it is here that this deficiency can be corrected.  It is hoped that
you will find benefit in this form and the ease with which complex
programs can be documented.  In any event a few minutes perusal should
prove worthwhile for novitiate programmers.  Even seasoned coders are
apt to appreciate an old trick included, using subroutines that call
themselves.
